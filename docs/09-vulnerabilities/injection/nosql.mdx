---
title: NoSQL Injection
---

# NoSQL Injection

## Description

A NoSQL injection vulnerability occurs when users can insert (or “inject”) malicious NoSQL code in a legit SQL query that is built from user-submitted input.
A successful NoSQL injection exploit can read sensitive data from the database, modify database data, execute administration operations on the database (such as shutting down the DBMS), recover the content of a given file from the DBMS file system and in some cases issue commands to the operating system.


## Remediation

The main principle of the remediation is to escape user input properly:
- Allow-list input validation.
- Escaping all user supplied input.



### GraphQL Specific

<details>
    <summary>Apollo</summary>

To prevent NoSQL injection in Apollo, validate and sanitize all user inputs. Use parameterized queries or the graphql-tools library to create a schema that defines how data can be queried and mutated.

</details>

<details>
    <summary>Yoga</summary>

In Yoga, ensure that all inputs are validated against the schema and use parameterized queries to avoid direct injection of user input into database queries.

</details>

<details>
    <summary>Awsappsync</summary>

For AWS AppSync, use AWS WAF to apply web filtering rules that block common injection patterns. Also, leverage VTL resolvers to sanitize and validate input arguments.

</details>

<details>
    <summary>Graphqlgo</summary>

In GraphQL Go, use the graphql-go library to define your schema with strong types and input validation to prevent NoSQL injections.

</details>

<details>
    <summary>Graphqlruby</summary>

For GraphQL Ruby, use the built-in input object types with argument validation to ensure that all user input is properly sanitized before hitting the database.

</details>

<details>
    <summary>Hasura</summary>

With Hasura, use permission rules to restrict access and validate inputs using check constraints or custom business logic in actions or remote schemas.

</details>


### REST Specific

<details>
    <summary>Asp.net</summary>

In ASP.NET, use parameterized queries with Entity Framework or ADO.NET to prevent NoSQL injection. Validate all user inputs using Data Annotations or custom validation logic.

</details>

<details>
    <summary>Ruby on rails</summary>

In Ruby on Rails, use Active Record query methods that are designed to prevent SQL injection, such as `where`, `find_by`, and `find`. Always sanitize inputs using Rails validators.

</details>

<details>
    <summary>Next.js</summary>

For Next.js API routes, use prepared statements with libraries like `pg` for PostgreSQL to prevent NoSQL injection. Validate and sanitize inputs using a library like `joi` or `express-validator`.

</details>

<details>
    <summary>Laravel</summary>

In Laravel, use Eloquent ORM or the query builder with parameter binding to protect against NoSQL injection. Validate requests using Laravel's built-in validation features.

</details>

<details>
    <summary>Express.js</summary>

With Express.js, use middleware like `express-validator` to validate and sanitize input data. Use parameterized queries with your database client to prevent NoSQL injection.

</details>

<details>
    <summary>Django</summary>

In Django, use the ORM's built-in filtering methods to prevent NoSQL injection. Always validate user input using Django forms or serializers.

</details>

<details>
    <summary>Symfony</summary>

For Symfony, use Doctrine's parameterized queries to prevent NoSQL injection. Validate and sanitize input data using Symfony's form and validation components.

</details>

<details>
    <summary>Spring boot</summary>

In Spring Boot, use JPA repositories with parameterized methods to prevent NoSQL injection. Apply validation annotations on your DTOs to ensure input data is valid.

</details>

<details>
    <summary>Flask</summary>

In Flask, use SQLAlchemy with parameterized queries to prevent NoSQL injection. Validate input using libraries like WTForms or Marshmallow.

</details>

<details>
    <summary>Nuxt</summary>

For Nuxt.js with serverMiddleware, use parameterized queries with your database client and validate inputs using libraries like `validator` or `joi`.

</details>

## Configuration

> Identifier: `injection/nosql`

### Options

- **skip_objects** : List of object that are to be skipped by the security test.




### Examples



#### Ignore this check

```json
{
    "checks": {
        "injection/nosql": {
            "skip": true
        }
    }
}
```




## Score

- Escape Severity: **<span className="high-severity">HIGH</span>**

### Compliance

- OWASP: **[API9:2023](https://github.com/OWASP/API-Security/blob/master/editions/2023/en/0xa9-improper-inventory-management.md)**
- pci: **6.5.1**
- gdpr: **Article-32**
- soc2: **CC6.1**
- psd2: **Article-95**
- iso27001: **A.14.2**
- nist: **SP800-53**
- fedramp: **AC-6**

### Classification






### Score

- CVSS_VECTOR: **CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H/E:H/RL:O/RC:C**
- CVSS_SCORE: **9.4**

## References

- [https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection)
  
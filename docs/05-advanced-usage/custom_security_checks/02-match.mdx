---
title: Matcher
---

# Matcher

In custom security check implementations, you usually want to match on various criterias, whether or not it's a response the scanner has collected, or it's in the API specification.


Escape enables you to write powerful matching rules, with logical blocks and a deep understanding of the data types used (scalars)

## Logic block

Here's how to match all requests that fill these conditions:

- The response code must be 200 AND considered a success
- AND
- Either the response header is a JSON, or the request contained an AuthZ Bearer token
- AND
- The request was a CREATE CRUD and its path ended with `/somepath`

```yaml
custom_checks:
  - name: 'test'
    matchers:
      - match:
          - response_code: 200
          - response_success: true # similar to 200 OK but Escape's built-in detection can avoid the errors returned with 200
          - or:
              - response_header:
                  header: 'Content-Type'
                  regex: 'application/json'
              - request_header:
                  header: 'Authorization'
                  regex: 'Bearer (.*)'
          - and:
              - request_crud:
                  - CREATE
              - request_path:
                  regex: '.*/somepath'

```

## Matcher types

### response_code
Simply match on HTTP response codes
```yaml
              - response_code: 200
              - response_code:
                  gt: 200
                  lt: 299
```

### response_success
Use the built-in Escape success detection to avoid false 200 OK that contain errors
```yaml
              - response_success: true | false
```

### response_header & request_header
Use regular expressions to detect key-value or key-any value for headers in either the request or response
```yaml
              - request_header:
                  header: 'Authorization'
                  regex: 'Bearer (.*)'
              - response_header:
                  header: 'Content-Type'
                  regex: 'application/json'
```

### response_body & request_body
Apply regular expression on the whole body of a request or response
```yaml
              - response_body:
                  regex: 'data\:.*'
              - request_body:
                  regex: 'data\:.*'
```

### response_json & request_json
Like previous, but specifically for detected JSON data, you can use JQ/JSONPath to apply more complex filters, make sure to evaluate to a boolean at the end.
```yaml
              - response_json: # on json
                  jq: '.data.items | length > 0'
```

### request_crud
Use Escape's built-in detection of CRUD operation types to filter your API operations.
```yaml
              - request_crud:
                  - CREATE
                  - READ
                  - UPDATE
                  - DELETE
```

### request_path
Match your URL path using regex (REST-only)
```yaml
              - request_path:
                  regex: '.*/register'
```

### request_scalar and response_scalar
Use Escape's intelligent categorization and inference of data types in both your request and response data to really target business-logic related objects.
You can view the supported list of scalars at [Escape Data Types Reference](https://docs.escape.tech/advanced-usage/data-types-reference)
```yaml
          - request_scalar:
              kind: 'EMAIL'
              regex: '(.*)@escape.tech'
          - response_scalar:
              kind: 'EMAIL'
              regex: '(.*)@escape.tech'
```

### sent_by_this_check
This is a special kind of logic operator, to choose whether your match should only consume its own generated requests via fuzzing.

This is pretty much how you can implement the feedback loop in all your tests, to Match targets, Fuzz them, and Match again to Alert.

```yaml
          - sent_by_this_check: true
```

### metadata
In custom security checks, you can attach your own metadata to fuzzed requests, or observe existing metadata.
This enables you to pass information between stages of your security test, to know which phase of the matchers you are in and apply different steps.

```yaml
          - metadata:
              key: 'ssrf_state'
              value: 'fuzzing' ## set this when we start fuzzing with payloads
```

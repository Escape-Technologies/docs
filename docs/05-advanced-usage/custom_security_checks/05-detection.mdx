---
title: Detection
---

# Detection

In your security test, you must define what are the criteria to raise an alert.
For that you have a lot of matchers available to match on the request, the response, the schema or the scan type.

The detection block is a list of detection rules, each rule is evaluated independently and if all the rules are matched,
an alert is raised. This means that you can define multiple matchers to fine tune your detection.

For example, a check that will raise an alert if the response status code is 500 to a route that contains `debug` in the url :

```yaml
detection:
  - detect: response.status_code
    is: 500
  - detect: schema.url
    contains: "debug"
```

## Available keys

With all the aforementioned matchers, you can match on the following keys :

- [scan.type](#scantype)
- [schema.operation](#schemaoperation)
- [schema.need_authentication](#schemaneed_authentication)
- [schema.url](#schemaurl)
- [schema.method](#schemamethod)
- [request.is_authenticated](#requestis_authenticated)
- [request.user](#requestuser)
- [request.headers](#requestheaders)
- [request.body](#requestbody)
- [helpers.request.scalars](#helpersrequestscalars)
- [helpers.request.crud](#helpersrequestcrud)
- [response.status_code](#responsestatus_code)
- [response.duration_ms](#responseduration_ms)
- [response.headers](#responseheaders)
- [response.body](#responsebody)
- [helpers.response.scalars](#helpersresponsescalars)
- [helpers.response.is_successful](#helpersresponseis_successful)

### scan.type

> type: [`enum`](#enum-matcher)

You can test the scan type to run some specific tests only for specific applications.

Example :

```yaml
detection:
  - detect: scan.type
    is: "REST"
```

### schema.operation

> type: [`string`](#string-matcher)



### schema.need_authentication

> type: [`bool`](#boolean-matcher)

### schema.url

> type: `aaa`

### schema.method

> type: `aaa`

### request.is_authenticated

> type: [`bool`](#boolean-matcher)

### request.user

> type: `aaa`

### request.headers

> type: `aaa`

### request.body

> type: [`string`](#string-matcher) / [`dict`](#dictionary-matcher) / [`JSON`](#json-matcher)

### helpers.request.scalars

> type: `aaa`

### helpers.request.crud

> type: `aaa`

### response.status_code

> type: [`integer`](#integer-matcher)

### response.duration_ms

> type: [`integer`](#integer-matcher)

### response.headers

> type: `aaa`

### response.body

> type: [`string`](#string-matcher) / [`dict`](#dictionary-matcher) / [`JSON`](#json-matcher)

### helpers.response.scalars

> type: `aaa`

### helpers.response.is_successful

> type: [`bool`](#boolean-matcher)

## Matchers

There are various types of matchers available:

- [Boolean](#boolean-matcher)
- [String](#string-matcher)
- [Integer](#integer-matcher)
- [Enum](#enum-matcher)
- [Dictionary](#dictionary-matcher)
- [JSON](#json-matcher)
- [Scalar](#scalar-matcher)

### Boolean matcher

You can match over a boolean with the simple `is` matcher.

Example :

```yaml
detection:
  - detect: helpers.response.is_successful
    is: true
```

### String matcher

You can match over a string in a lot of different ways :

- `is` : The string is exactly the same
- `in` : The string is in the given list
- `contains` : The string contains the given value
- `regex` : The string full match the given regex with ignore case flag (you can try your regex [here](https://regex101.com/))

Example :

```yaml
detection:
  - detect: schema.url
    contains: "admin"
```

### Integer matcher

You can match over a integer in a lot of different ways :

- `is` : The integer is equal
- `is_not` : The integer is not equal
- `in` : The integer is in the given list
- `gt` : The integer is greater than the given value (or equal)
- `lt` : The integer is lower than the given value (or equal)

You can combine `gt` and `lt` to create a range.

Example :

```yaml
detection:
  - detect: response.status_code
    gt: 200
    lt: 299
```

### Enum matcher

Some keys contain a single value that is defined in an Enum.

Example : 

```yaml
detection:
  - detect: helpers.request.crud # (= "CREATE")
    in:
      - "CREATE"
      - "READ"
```

### Dictionary matcher

For data that is structured as a dictionary of key-values and you want to match on both the key and value.

Example:

```yaml
detection:
  - detect: request.header
    key:
      # string matcher
      is: "Content-Type"
    value:
      # string matcher
      regex: "application/.*"
```

### JSON matcher

You can match over a JSON in a lot of different ways :

- `is` : The JSON is exactly the same as the given JSON
- `in` : The JSON is in the given list of JSON
- `key` : The given key is present in the JSON
- `jq` : The string match the given [jq](https://stedolan.github.io/jq/) filter

### Scalar matcher

Escape explore your API using scalars : each key of the query and the response will be extracted and stored as a scalar.
It can be helpful to understand what is the underlying type of a key in a from.

For example you may have a `user_id` key typed as string in your json schema, but in the underlying database store it as an UUID,
escape will tag this key as `ID` and `UUID`, and during the scan, this scalars will be refined to `UUID` only.

You so can match the scalar type using an enum matcher with our predefined scalars :

```yaml
detection:
  - detect: helpers.response.scalars
    type:
      in:
        - "IPV4"
        - "IPV6"
```

You can also match a scalar by it's name using a string matcher :

```yaml
detection:
  - detect: helpers.response.scalars
    name:
      # string matcher
      regex: ".*@escape.tech"
```
You can also match a scalar by value using a string matcher :

```yaml
detection:
  - detect: helpers.response.scalars
    value:
      # string matcher
      regex: ".*@escape.tech"
```

You can also match on the sensitivity of a scalar using an enum matcher:

```yaml
detection:
  - detect: helpers.response.scalars
    sensitivity:
      in:
        - "HIGH"
        - "MEDIUM"
```

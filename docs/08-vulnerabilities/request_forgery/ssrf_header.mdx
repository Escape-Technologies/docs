---
title: SSRF Injection in headers
---

# SSRF Injection in headers

## Description

SSRF flaws occur whenever a web application is fetching a remote resource without validating the user-supplied URL.
It allows an attacker to coerce the application to send a crafted request to an unexpected destination, even when protected by a firewall, VPN, or another type of network access control list (ACL).


## Remediation

How to prevent:
- Segment remote resource access functionality in separate networks to reduce the impact of SSRF.
- Sanitize and validate all client-supplied input data.
- Enforce the URL schema, port, and destination with a positive allow list.
- Disable HTTP redirections.



### REST Specific

<details>
    <summary>Asp.net</summary>

In ASP.NET, validate and sanitize all URLs received from user input before using them to make requests. Use a whitelist of allowed domains to ensure only expected hosts are contacted.

</details>

<details>
    <summary>Ruby on rails</summary>

In Ruby on Rails, always validate the URL against a set of known good patterns or domains before making HTTP calls.

</details>

<details>
    <summary>Next.js</summary>

In Next.js, ensure that any user-provided URLs are validated against a list of allowed domains before being used in server-side requests.

</details>

<details>
    <summary>Laravel</summary>

In Laravel, use the built-in validation rules to ensure the URL is well-formed and belongs to a list of allowed hosts before making outgoing requests.

</details>

<details>
    <summary>Express.js</summary>

In Express.js, validate the URL with a custom middleware that checks the hostname against a list of allowed domains before proceeding with the request.

</details>

<details>
    <summary>Django</summary>

In Django, use the URLValidator to ensure the URL is valid and then check the domain against a whitelist before making the request.

</details>

<details>
    <summary>Symfony</summary>

In Symfony, use the Validator component to validate the URL and check if the domain is in the list of allowed domains before making the request.

</details>

<details>
    <summary>Spring boot</summary>

In Spring Boot, use a custom validator to ensure the URL's domain is allowed before making any outgoing requests.

</details>

<details>
    <summary>Flask</summary>

In Flask, validate the URL using Werkzeug's URL parsing utilities and check the domain against a whitelist before making the request.

</details>

<details>
    <summary>Nuxt</summary>

In Nuxt.js, validate the URL on the server-side before making any API calls, ensuring the domain is within a set of allowed domains.

</details>

## Configuration

> Identifier: `request_forgery/ssrf_header`



### Examples



#### Ignore this check

```json
{
    "checks": {
        "request_forgery/ssrf_header": {
            "skip": true
        }
    }
}
```




## Score

- Escape Severity: **<span className="low-severity">LOW</span>**

### Compliance

- OWASP: **[API10:2023](https://github.com/OWASP/API-Security/blob/master/editions/2023/en/0xaa-unsafe-consumption-of-apis.md)**
- pci: **6.5.6**
- gdpr: **Article-32**
- soc2: **CC6.1**
- psd2: **Article-95**
- iso27001: **A.14.2**
- nist: **SP800-53**
- fedramp: **AC-4**

### Classification






### Score

- CVSS_VECTOR: **CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L**
- CVSS_SCORE: **7.3**


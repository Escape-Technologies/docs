---
title: Tenant isolation
---

# Tenant isolation

## Description

Uses the rules defined by the users to detect same object instances detected by two different users whereas this is prohibited.
According to the rules provided in the configuration file, the same instance or object can be detected by two different users which is prohibited.


## Remediation

When accessing the application via GraphQL, we must validate whether or not the user has access to the requested elements from the schema.
Especially we must implement access control policies **on every path** of the Graph leading considered field or object.

The authorization logic belongs to the [business logic](https://escape.tech/blog/what-is-business-logic-and-why-its-important/) layer, and from there it is accessed by GraphQL. 
This way, the application can have a single source of truth for authorization, which can then be used for other access points.

Among the several access control policies we can implement in our application, the two most popular ones are **Role-Based Access Control** (RBAC) and **Attribute-Based Access Control** (ABAC).
  - With **Role-Based Access Control**, we grant permissions based on roles, and then assign the roles to the users. For instance, WordPress has an `administrator` role with access to all resources, and the `editor`, `author`, `contributor`, and `subscriber` roles, which each restrict permissions in varying degrees, such as being able to create and publish a blog post, just create it, or just read it.
  - With **Attribute-Based Access Control**, permissions are granted based on metadata that can be assigned to different entities, including users, assets, and environment conditions (such as the time of the day or the visitor's IP address). For instance, in WordPress, the capability `edit_others_posts` is used to validate whether the user can edit other users' posts.

In general terms, ABAC is preferable over RBAC because it allows us to configure permissions with fine-grained control, and the permission is unequivocal in its objective.



### GraphQL Specific

<details>
    <summary>Apollo</summary>

See [Apollo's Access Control Documentation](https://www.apollographql.com/docs/apollo-server/security/authentication/#in-resolvers). For large scale applications, you might want to use a specific package like [graphql-shield](https://github.com/maticzav/graphql-shield) for easy Access Control Management.

</details>

<details>
    <summary>Hasura</summary>

See Hasura's detailed documentation for Authorization Management [here](https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules/)

</details>

<details>
    <summary>Awsappsync</summary>

Appsync provides several methods for protecting critical information. - For implementing fine-grained access control, see https://docs.aws.amazon.com/appsync/latest/devguide/security-authz.html#fine-grained-access-control

</details>

<details>
    <summary>Yoga</summary>

In GraphQL Yoga, you can implement custom authentication logic within your resolvers to ensure that users can only access data they are permitted to. Use context to pass user information and validate access rights.

</details>

<details>
    <summary>Graphqlgo</summary>

In GraphQL-Go, ensure that your resolver functions include logic to check whether the user is authorized to access the data they are requesting.

</details>

<details>
    <summary>Graphqlruby</summary>

In GraphQL-Ruby, use the `authorized?` method in your types to define authorization logic for accessing objects.

</details>


### REST Specific

<details>
    <summary>Asp.net</summary>

Use ASP.NET Core's built-in authorization features to restrict access to endpoints based on user roles or claims.

</details>

<details>
    <summary>Ruby on rails</summary>

Leverage Rails' `before_action` filters to check for user permissions before granting access to controller actions.

</details>

<details>
    <summary>Next.js</summary>

In Next.js API routes, use middleware or helper functions to authenticate and authorize users before processing the request.

</details>

<details>
    <summary>Laravel</summary>

Utilize Laravel's middleware and policies to enforce user permissions on routes and actions.

</details>

<details>
    <summary>Express.js</summary>

Implement middleware in Express.js to authenticate and authorize users before they can access protected routes.

</details>

<details>
    <summary>Django</summary>

Use Django's authentication and permission system to protect views and ensure that only authorized users can access them.

</details>

<details>
    <summary>Symfony</summary>

In Symfony, secure your controllers with access control rules defined in security.yaml or with annotations in your controller classes.

</details>

<details>
    <summary>Spring boot</summary>

Apply Spring Security annotations to your Spring Boot controllers to enforce authentication and authorization.

</details>

<details>
    <summary>Flask</summary>

In Flask, use decorators to require login or specific permissions before accessing certain views.

</details>

<details>
    <summary>Nuxt</summary>

For Nuxt.js, use middleware to check if the user is authenticated and authorized before rendering pages or processing API requests.

</details>

## Configuration

> Identifier: `access_control/tenant_isolation`

### Parameters


**objects** : A list of private `objectNames`. A single instance of this object should not be access by 2 different users. Each object instance is identified by its ID.


**scalars** : A list of scalar `fieldName`. A specific `scalarValue` of this field should not be access by 2 different users. Each scalar instance is indentified by its value.


**paths** : List of the paths of the routes to control, compliant with the OpenAPI route format. See https://swagger.io/docs/specification/paths-and-operations/.





### Examples



#### **GraphQL:** Accessiblity of objects private instances for differents users

```
{
  ... Authentication settings ...
  ... Other configuration settings ...

  "checks": {

    ... Other checks ...

    "access_control/tenant_isolation": {
      "parameters": {
        "objects": [
          "MyVeryPrivateData",            # Record access to object `MyVeryPrivateData`
                                          #  if two different users access the same object
                                          #  (i.e. two different users access the same self bound private data)
                                          #  the an alert will be raised.
        ],
        "scalars": {
          "Post": [
            "createdBy",                  # Record access to field `createdBy` of object `Post`
                                          #  if two different users can access the same scalar value
                                          #  an alert will be raised.
          ]
        }
      }
    }

    ... Other checks ...
  }

  ... Other configuration settings ...
}
```




#### **REST:** Enforce tenant isolation on path /users/{id} and /me

```
{
  ... Authentication settings ...
  ... Other configuration settings ...

  "checks": {

    ... Other checks ...

    "access_control/tenant_isolation": {
      "parameters": {
        "paths": [
          "/users/{id}",
          "/me"
        ]
      }
    }

    ... Other checks ...
  }

  ... Other configuration settings ...
}
```




#### Ignore this check

```json
{
    "checks": {
        "access_control/tenant_isolation": {
            "skip": true
        }
    }
}
```




## Score

- Escape Severity: **<span className="high-severity">HIGH</span>**
  - OWASP: **[API5:2023](https://github.com/OWASP/API-Security/blob/master/editions/2023/en/0xa5-broken-function-level-authorization.md)**
  - PCI DSS: **6.5.8**
  - CWE
    - **200**
    - **201**
    - **284**
    - **668**
    - **1198**
    - **1212**
    - **1220**
  - WASC: **WASC-22**
  
  






## References

- [https://blog.logrocket.com/authorization-access-control-graphql/](https://blog.logrocket.com/authorization-access-control-graphql/)
  

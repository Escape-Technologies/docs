---
title: Duplicated object
---

# Duplicated object

## Description

Duplicated objects in OpenAPI or GraphQL schemas can lead to maintenance difficulties, increased complexity, data inconsistencies, performance issues, integration challenges, and documentation problems. This redundancy complicates API management and usage.


## Remediation

Remove duplicated objects from the schema.



### GraphQL Specific

<details>
    <summary>Apollo</summary>

In Apollo framework, ensure that your GraphQL schema definitions are modularized and use schema stitching or type extensions to avoid duplication. Employ tools like Apollo's schema validation to detect and merge duplicate types and resolvers, streamlining your API and improving maintainability.

</details>

<details>
    <summary>Yoga</summary>

In the Yoga framework, ensure that your schema definitions are modular and leverage schema stitching or directives to avoid duplication. Refactor any repeated types, fields, or resolvers to maintain a single source of truth, which simplifies maintenance and prevents inconsistencies.

</details>

<details>
    <summary>Awsappsync</summary>

In AWS AppSync, ensure that your GraphQL schema is designed with single sources of truth for object types and avoid duplicating type definitions. Utilize schema stitching or modularization to share common types across different schema parts. Regularly refactor your schema to merge or alias duplicated objects, and consider implementing schema validation tools to detect and prevent duplication during development.

</details>

<details>
    <summary>Graphqlgo</summary>

In the GraphQLGo framework, ensure that your schema definitions are modular and leverage schema stitching to combine them. Avoid defining the same types, fields, or resolvers multiple times across different parts of your schema. Utilize GraphQL directives, interfaces, or unions to create reusable components. Regularly refactor your schema to merge or abstract duplicated elements, and consider using schema validation tools to detect and resolve duplications early in the development process.

</details>

<details>
    <summary>Graphqlruby</summary>

In the GraphQL-Ruby framework, ensure that types, fields, and resolvers are defined only once and reused across the schema. Utilize modules or Ruby classes to encapsulate common structures and logic, and apply the DRY (Don't Repeat Yourself) principle to avoid duplication. Regularly refactor your schema to merge similar types and fields, and consider using interfaces or unions for shared functionality. This will help maintain a clean and efficient codebase, reduce potential errors, and simplify both development and API consumption.

</details>

<details>
    <summary>Hasura</summary>

In Hasura, ensure that your GraphQL schema is designed with reusable fragments and input types to avoid duplication. Regularly refactor your schema to merge similar types and use abstract types like interfaces or unions to handle overlapping fields. This will help maintain a clean and efficient API structure.

</details>


### REST Specific

<details>
    <summary>Asp_net</summary>

In the ASP.NET framework, to address the issue of duplicated objects, refactor your codebase to implement the 'Don't Repeat Yourself' (DRY) principle. Consolidate duplicate classes, methods, or schemas into single, reusable components. Utilize inheritance, interfaces, or shared libraries to abstract common functionality. Regularly review your code for redundancies and apply migrations or updates to ensure a single source of truth for each object definition. This will simplify maintenance, reduce errors, and improve the overall performance and scalability of your application.

</details>

<details>
    <summary>Ruby_on_rails</summary>

In Ruby on Rails, to address the issue of duplicated objects in your OpenAPI or GraphQL schemas, refactor your codebase to utilize shared definitions or components. Employ modules or concerns to encapsulate common functionality and types, and use inheritance or mixins to avoid duplication. Ensure that your API documentation is updated accordingly to reflect these changes for clarity and ease of use.

</details>

<details>
    <summary>Next_js</summary>

Consolidate duplicated components and utilize module imports to maintain a single source of truth, enhancing maintainability and reducing complexity in your Next.js application.

</details>

<details>
    <summary>Laravel</summary>

In Laravel, to avoid duplication in your Eloquent models or database migrations, utilize traits for common methods and relationships, and leverage database seeders and factories for consistent data creation. Regularly refactor your code to ensure DRY (Don't Repeat Yourself) principles are followed.

</details>

<details>
    <summary>Express_js</summary>

In Express.js, avoid defining duplicate middleware or route handlers that can cause conflicts or unexpected behavior. Refactor your code to create reusable functions or modules, and ensure that each endpoint is handled by a unique function. Regularly review your routes and middleware for any redundancy and consolidate them when possible to maintain a clean and efficient codebase.

</details>

<details>
    <summary>Django</summary>

In Django, ensure that your models, serializers, and views are designed with the DRY (Don't Repeat Yourself) principle in mind. Refactor any duplicated code by creating abstract base classes, mixins, or utility functions that can be shared across different parts of your application. Regularly review your codebase for redundancies and consolidate any duplicate logic or schema definitions to maintain a clean and efficient codebase.

</details>

<details>
    <summary>Symfony</summary>

In Symfony, to avoid duplication in your API schemas, utilize inheritance and composition with the Serializer component or leverage the PHP8 Attributes in combination with the Symfony Serializer to define reusable schema components. Employ services and dependency injection to share common logic across your application.

</details>

<details>
    <summary>Spring_boot</summary>

In Spring Boot, to address the issue of duplicated objects in OpenAPI or GraphQL schemas, refactor the codebase to create shared DTOs (Data Transfer Objects) or entities that can be reused across different API endpoints. Utilize inheritance or composition to handle common properties and reduce redundancy. Ensure that all references to these objects are updated to point to the shared definitions. Additionally, consider using libraries like ModelMapper to simplify object mapping and maintain consistency. Regularly review your schema to identify potential duplications as part of your API governance process.

</details>

<details>
    <summary>Flask</summary>

In Flask, to avoid duplication in your API schema, utilize inheritance with Python classes or leverage Flask extensions like Flask-RESTPlus or Flask-RESTful. These tools encourage code reuse and help define resources in a clean, DRY (Don't Repeat Yourself) manner. Regularly refactor your code to abstract common functionality and use decorators for shared behavior across endpoints.

</details>

<details>
    <summary>Nuxt</summary>

In Nuxt.js, ensure that components, plugins, and store modules are named and structured uniquely to prevent duplication. Refactor any existing duplicated code by creating reusable components or mixins, and utilize Vuex for shared state management to maintain a single source of truth.

</details>

<details>
    <summary>Fastapi</summary>

In FastAPI, ensure that your schema definitions are centralized and reused rather than duplicated. Utilize Pydantic models to define data structures once and reference them across your endpoints. This approach will help maintain consistency, reduce errors, and simplify updates to your API structure.

</details>

## Configuration

> Identifier: `schema/duplicated_object`



### Examples



#### Ignore this check

```yaml
checks:
  schema/duplicated_object:
    skip: true
```




## Score

- Escape Severity: **<span className="info-severityom">INFO</span>**

### Compliance

- OWASP: **[API9:2023](https://github.com/OWASP/API-Security/blob/master/editions/2023/en/0xa9-improper-inventory-management.md)**
- pci: **6.5.1**
- gdpr: **Article-32**
- soc2: **CC1**
- psd2: **Article-95**
- iso27001: **A.12.6**
- nist: **SP800-53**
- fedramp: **CM-3**

### Classification






### Score

- CVSS_VECTOR: **CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N**


